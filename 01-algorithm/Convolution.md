- [数学本质：线性系统的全局描述](#数学本质线性系统的全局描述)
  - [核心公式：](#核心公式)
  - [物理意义：](#物理意义)
- [两个矩形脉冲的连续卷积](#两个矩形脉冲的连续卷积)
  - [计算步骤](#计算步骤)
    - [确定非零重叠区间：](#确定非零重叠区间)
    - [分段讨论 t 的取值：](#分段讨论-t-的取值)
    - [最终结果](#最终结果)
- [3D张量的二维卷积（多通道卷积）](#3d张量的二维卷积多通道卷积)
  - [输入数据](#输入数据)
  - [卷积核](#卷积核)
  - [计算步骤](#计算步骤-1)
    - [输入各通道的 2×2 区域：](#输入各通道的-22-区域)
    - [逐通道计算点积：](#逐通道计算点积)
    - [跨通道求和：](#跨通道求和)
  - [输出结果](#输出结果)




本文主要对卷积的定义和意义进行了梳理，对连续卷积和离散卷积的计算分别举例。

# 数学本质：线性系统的全局描述

卷积的数学意义在于，它提供了一种将两个函数（或信号）的相互作用编码为单一输出的方式。


## 核心公式：

$$
(f∗g)(t)=\int_{-∞}^{∞}{f(τ)g(t-τ)dτ}（连续）
$$


由于 $f(τ)$ 和 $g(t−τ)$ 仅在特定区间非零，积分范围需分段讨论。


## 物理意义：

表示系统对输入的响应是历史所有输入的加权累积（例如：回声是过去声音的延迟叠加）。

# 两个矩形脉冲的连续卷积

输入信号 $f(t)$ ：

$$
f(t)=\left \{{\begin{matrix}1&0≤t≤1\\0&others\end{matrix}}\right .
$$

卷积核 $g(t)$ ：

$$
g(t)=\left \{{\begin{matrix}1&0≤t≤1\\0&others\end{matrix}}\right .
$$

## 计算步骤

### 确定非零重叠区间：

$f(τ)$ 非零当 $0≤τ≤1$

$g(t−τ)$ 非零当 $0≤t−τ≤1$，即 $t−1≤τ≤t$。

因此，积分的有效区间为两个区间的交集：

$$
max(0,t−1)≤τ≤min(1,t)
$$

### 分段讨论 t 的取值：

情况 1：$t<0$ 或 $t>2$

无重叠区域，卷积结果 

$$
(f∗g)(t)=0
$$

情况 2：$0≤t≤1$

积分区间：$0≤τ≤t$

计算：

$$
(f∗g)(t)=\int_{0}^{t}{1⋅1dτ}=t
$$

情况 3：$1<t≤2$

积分区间：$t−1≤τ≤1$

计算：

$$
(f∗g)(t)=\int_{t-1}^{1}{1⋅1dτ}=1-(t-1)=2-t
$$


### 最终结果

$$
(f∗g)(t)=\left \{{\begin{matrix}0&t<0\\t&0≤t≤1\\2-t&1<t<2\\0&t>2\end{matrix}}\right .
$$

几何意义：

结果是一个底边长为 2 的等腰三角形（三角波），顶点在 $t=1$ 时达到最大值 1。

关键点

- 重叠区间分析：卷积的物理意义是两信号在时移过程中的重叠面积。
- 分段积分：根据 t 的位置调整积分上下限。
- 对称性：两个相同矩形脉冲的卷积生成对称三角波，体现信号“扩散”特性。


**MATLAB**


```
% 定义时间范围和步长
dt = 0.01;
t = -0.5:dt:2.5;  % 扩展时间范围以显示完整过程

% 定义输入信号 f(t) 和卷积核 g(t)
f = (t >= 0) & (t <= 1);  % 矩形脉冲 [0,1]
g = (t >= 0) & (t <= 1);  % 矩形脉冲 [0,1]

% 计算卷积（注意要乘以时间步长 dt）
conv_result = conv(f, g, 'full') * dt;

% 生成卷积结果的时间轴
t_conv = linspace(t(1)+t(1), t(end)+t(end), length(conv_result));

% 绘制原始信号和卷积结果
figure('Color', 'white', 'Position', [100, 100, 1000, 400])

% 绘制输入信号 f(t)
subplot(1, 3, 1)
plot(t, f, 'LineWidth', 2)
xlim([-0.5 2.5])
title('输入信号 f(t)')
xlabel('时间 t')
ylabel('幅值')
grid on

% 绘制卷积核 g(t)
subplot(1, 3, 2)
plot(t, g, 'LineWidth', 2)
xlim([-0.5 2.5])
title('卷积核 g(t)')
xlabel('时间 t')
ylabel('幅值')
grid on

% 绘制卷积结果
subplot(1, 3, 3)
plot(t_conv, conv_result, 'r', 'LineWidth', 2)
xlim([-0.5 2.5])
title('卷积结果 f(t)*g(t)')
xlabel('时间 t')
ylabel('幅值')
grid on

% 添加理论三角形参考线（红色虚线）
hold on
plot([0 1 2], [0 1 0], '--r', 'LineWidth', 1)
legend('数值计算', '理论三角形', 'Location', 'north')
```

代码说明：

**信号定义：**

- 使用逻辑索引创建两个矩形脉冲信号 f(t) 和 g(t)
- 时间范围扩展为 [-0.5, 2.5] 以完整显示信号和卷积结果

**卷积计算：**

- conv(f, g, 'full') 计算全卷积
- 乘以时间步长 dt 来近似连续卷积积分

基本语法

```
C = conv(A, B)        % 默认使用 'full' 模式
C = conv(A, B, shape) % 指定卷积结果的输出模式
```

输入参数：

A, B：待卷积的两个向量（可以是行向量或列向量）。

shape（可选）：指定卷积结果的输出范围，可选值为 'full'、'same' 或 'valid'。

输出：

C：卷积结果向量。

**'full' 模式（默认）**

输出范围：包含所有可能的重叠部分。

输出长度：length(A) + length(B) - 1。

适用场景：需要完整卷积结果时（如理论分析）。


**'same' 模式**

输出范围：中心部分，与输入 A 长度相同。

输出长度：max(length(A), length(B))。

适用场景：保持输出与输入信号长度一致（如实时信号处理）。


**'valid' 模式**

输出范围：仅完全重叠部分。

输出长度：max(length(A) - length(B) + 1, 0)。

适用场景：忽略边界效应（如数据特征提取）。



  
**时间轴对齐：**

- 卷积结果的时间范围是原始信号时间范围的叠加
- 使用 linspace 生成对应的时间轴 t_conv

conv() 输出的索引默认从 1 开始，若需要物理时间轴，需手动计算

**可视化：**

- 分三个子图显示输入信号、卷积核和卷积结果
- 添加红色虚线显示理论三角形波形作为参考



# 3D张量的二维卷积（多通道卷积）

以下是一个3D张量的二维卷积（多通道卷积）的简单示例，展示了多通道输入和输出的计算过程：


假设有一个输入张量（例如RGB图像）和两个卷积核，演示如何生成多通道输出。


## 输入数据

形状：(3, 3, 3) → 3个通道（如R、G、B），每个通道是 3×3 的矩阵。


```
# 通道1（R）
[[1, 2, 3],
 [4, 5, 6],
 [7, 8, 9]]

# 通道2（G）
[[9, 8, 7],
 [6, 5, 4],
 [3, 2, 1]]

# 通道3（B）
[[2, 0, 1],
 [1, 2, 0],
 [0, 1, 2]]
 ```

## 卷积核

形状：(2, 3, 2, 2) → 2个输出通道，每个核有3个输入通道（与输入对应），每个通道是 2×2 的矩阵。


```
# 输出通道1的核（检测边缘）
- 输入通道1（R）：[[1, 0], [0, -1]]
- 输入通道2（G）：[[-1, 0], [0, 1]]
- 输入通道3（B）：[[0, 1], [-1, 0]]

# 输出通道2的核（检测中心）
- 输入通道1（R）：[[0, 1], [1, 0]]
- 输入通道2（G）：[[1, 0], [0, 1]]
- 输入通道3（B）：[[0, 0], [0, 0]]
```

## 计算步骤

以输出通道1为例，计算左上角位置（无填充，步长=1）：

### 输入各通道的 2×2 区域：

通道1（R）：

```
[1, 2]
[4, 5]
```

通道2（G）：

```
[9, 8]
[6, 5]
```

通道3（B）：

```
[2, 0]
[1, 2]
```

### 逐通道计算点积：


通道1：(1×1) + (2×0) + (4×0) + (5×-1) = 1 - 5 = -4

通道2：(9×-1) + (8×0) + (6×0) + (5×1) = -9 + 5 = -4

通道3：(2×0) + (0×1) + (1×-1) + (2×0) = -1


### 跨通道求和：

输出通道1的值：-4 + (-4) + (-1) = -9

同理，滑动窗口计算所有位置，最终得到输出特征图。


## 输出结果

输出形状：(2, 2, 2) → 2个通道，每个通道是 2×2 矩阵。

输出通道1（边缘检测）：

```
[-9,  -5]
[ 3,  -2]
```

输出通道2（中心检测）：

```
[25, 20]
[13,  8]
```


```
import torch
import torch.nn as nn

# 定义输入张量 (3通道, 3x3)
input_tensor = torch.tensor([
    [[1, 2, 3], [4, 5, 6], [7, 8, 9]],          # 通道1
    [[9, 8, 7], [6, 5, 4], [3, 2, 1]],          # 通道2
    [[2, 0, 1], [1, 2, 0], [0, 1, 2]]           # 通道3
], dtype=torch.float32).unsqueeze(0)  # 添加 batch 维度 → (1, 3, 3, 3)

# 定义卷积层：输入3通道，输出2通道，核大小2x2
conv = nn.Conv2d(in_channels=3, out_channels=2, kernel_size=2, bias=False)

# 手动设置核权重（对应示例中的值）
conv.weight.data = torch.tensor([
    # 输出通道1的核
    [[[1, 0], [0, -1]],   # 输入通道1
     [[-1, 0], [0, 1]],   # 输入通道2
     [[0, 1], [-1, 0]]],  # 输入通道3
    # 输出通道2的核
    [[[0, 1], [1, 0]],    # 输入通道1
     [[1, 0], [0, 1]],    # 输入通道2
     [[0, 0], [0, 0]]]    # 输入通道3
], dtype=torch.float32)

# 执行卷积
output = conv(input_tensor)
print(output.squeeze(0).detach())
# 输出形状为 (2, 2, 2)，对应两个通道的特征图
```





